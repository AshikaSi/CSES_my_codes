#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// #include <bits/stdc++.h>
#include <complex>
#include <queue>
#include <set>
#include <unordered_set>
#include <list>
#include <chrono>
#include <random>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <string>
#include <vector>
#include <map>
#include <unordered_map>
#include <stack>
#include <iomanip>
// #include <fstream>
using namespace std;
#define int long long
typedef long long ll;
typedef long double ld;
typedef pair<int,int> p32;
typedef pair<ll,ll> p64;
typedef pair<double,double> pdd;
typedef vector<ll> v64;
typedef vector<int> v32;
typedef vector<vector<int>> vv32;
typedef vector<vector<ll>> vv64;
typedef vector<vector<p64>> vvp64;
typedef vector<p64> vp64;
typedef vector<p32> vp32;
ll MOD = 998244353;
#define nah {cout<<"NO"<<endl; return;}
#define yeah {cout<<"YES"<<endl; return;}
#define ok(t) {cout<<t<<endl; return;}
#define vin(v) for(auto& x: v) cin >> x;
#define vout(v) for(auto x: v) cout << x << ' '; cout << endl;
double eps = 1e-12;
#define forn(i,e) for(ll i = 0; i < e; i++)
#define forsn(i,s,e) for(ll i = s; i < e; i++)
#define rforn(i,s) for(ll i = s; i >= 0; i--)
#define rforsn(i,s,e) for(ll i = s; i >= e; i--)
#define ln "\n"
#define dbg(x) cout << #x << " = " << x << ln
#define mp make_pair
#define pb push_back
#define fi first
#define se second
#define INF 2e18
#define Ashika ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
#define all(x) (x).begin(), (x).end()
#define sz(x) ((ll)(x).size())
// #define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>
// template <typename T, typename U> T cdiv(T x, U y) { assert(y != 0); return (x > 0 ? (x + y - 1) / y : x / y); }
// template <typename T, typename U> T fdiv(T x, U y) { assert(y != 0); return (x > 0 ? x / y : (x - y + 1) / y); }

void solve() {
    int n,m;
    cin >> n >> m;
     vector<int> arr(n + 1), pos(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> arr[i];
        pos[arr[i]] = i;
    }
    int rounds = 1;
    for (int i = 1; i < n; i++) {
        if (pos[i] > pos[i + 1])
            rounds++;
    }

    auto isBad = [&](int i) {
        if (i < 1 || i >= n) return false;
        return pos[i] > pos[i + 1];
    };

    while(m--) {
        int a,b;
        cin>> a >> b;

        int val1 = arr[a];
        int val2 = arr[b];

        // Remove old bad contributions
        if (isBad(val1 - 1)) rounds--;
        if (isBad(val1)) rounds--;
        if (isBad(val2 - 1) && val2 != val1 + 1 ) rounds--;
        if (isBad(val2) && val1 != val2 + 1) rounds--;
        
        swap(arr[a], arr[b]);
        pos[val1] = b;
        pos[val2] = a;

        // Add new bad contributions
        if (isBad(val1 - 1)) rounds++;
        if (isBad(val1)) rounds++;
        if (val2 != val1 + 1) {   // avoid double count
            if (isBad(val2 - 1)) rounds++;
        }
        if (val1 != val2 + 1) {   // avoid double count
            if (isBad(val2)) rounds++;
        }

        cout << rounds << "\n";
        
    }
}
int32_t main() {
    Ashika
    ll t = 1;
    // cin >> t; // comment if only one test case
    for(int it = 1; it <= t; it++) {
        solve();
    }
    return 0;
}
